<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NiYien Telemetry Stats</title>
  
  <!-- CSS Framework & Libs -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
  <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  
  <style>
    #map { height: 500px; width: 100%; border-radius: 0.5rem; z-index: 1; }
    .chart-container { position: relative; height: 300px; width: 100%; }
    [v-cloak] { display: none; }
  </style>
</head>
<body class="bg-gray-100 text-gray-800">

<div id="app" v-cloak class="min-h-screen p-4 md:p-8">
  <!-- Header & Controls -->
  <header class="mb-8 flex flex-col md:flex-row justify-between items-center gap-4">
    <div>
      <h1 class="text-3xl font-bold text-blue-600">NiYien 统计</h1>
      <p class="text-sm text-gray-500">遥测数据看板</p>
    </div>
    
    <div class="flex flex-col md:flex-row items-center gap-2">
      <div class="flex gap-2 bg-white p-1 rounded-lg shadow">
         <input 
           type="password" 
           v-model="token" 
           placeholder="令牌 (可选)" 
           class="px-3 py-2 rounded text-sm border-none focus:ring-0 w-32"
           @change="saveToken"
         >
         <div class="w-px bg-gray-200 my-1"></div>
         <button 
            v-for="d in durations" 
            :key="d.val"
            @click="loadStats(d.val)"
            :class="['px-4 py-2 rounded transition-colors text-sm', duration === d.val ? 'bg-blue-600 text-white' : 'hover:bg-gray-100']"
         >
            {{ d.label }}
         </button>
      </div>
      
      <!-- View Mode Toggle -->
      <div class="flex gap-1 bg-white p-1 rounded-lg shadow">
         <button @click="viewMode = 'total'" :class="['px-4 py-2 rounded text-sm transition-colors', viewMode === 'total' ? 'bg-emerald-100 text-emerald-800 font-medium' : 'hover:bg-gray-50 text-gray-600']">总开启次数</button>
         <button @click="viewMode = 'unique'" :class="['px-4 py-2 rounded text-sm transition-colors', viewMode === 'unique' ? 'bg-emerald-100 text-emerald-800 font-medium' : 'hover:bg-gray-50 text-gray-600']">独立用户数</button>
      </div>
    </div>
  </header>

  <!-- Error State -->
  <div v-if="error" class="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 mb-8" role="alert">
    <p>{{ error }}</p>
  </div>

  <!-- Loading State -->
  <div v-if="loading" class="text-center py-20">
    <div class="animate-spin h-10 w-10 border-4 border-blue-500 border-t-transparent rounded-full mx-auto mb-4"></div>
    <p class="text-gray-500">正在统计数据...</p>
  </div>

  <div v-if="!loading && data" class="space-y-8">
    
    <!-- KPI Cards -->
    <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
      <!-- Main Metric (Opens or Unique Users) -->
      <div class="bg-white p-6 rounded-xl shadow-sm border-l-4 border-blue-500">
         <div class="text-gray-500 text-sm font-medium mb-1">{{ currentStats.label }}</div>
         <div class="text-3xl font-bold">{{ currentStats.total.toLocaleString() }}</div>
      </div>

      <!-- Active Cities -->
      <div class="bg-white p-6 rounded-xl shadow-sm border-l-4 border-green-500">
         <div class="text-gray-500 text-sm font-medium mb-1">活跃城市</div>
         <div class="text-3xl font-bold">{{ Object.keys(currentStats.cities).length }}</div>
      </div>

      <!-- Inactive Users (Retention) -->
      <div class="bg-white p-6 rounded-xl shadow-sm border-l-4 border-purple-500">
         <div class="text-gray-500 text-sm font-medium leading-tight mb-1">活跃 / 不活跃 (30天)</div>
         <div class="flex items-baseline gap-2">
            <span class="text-2xl font-bold">{{ data.user_retention?.active_30d || 0 }}</span>
            <span class="text-gray-400 text-sm">/ {{ data.user_retention?.inactive_30d || 0 }}</span>
         </div>
      </div>

      <!-- Total Models -->
      <div class="bg-white p-6 rounded-xl shadow-sm border-l-4 border-orange-500">
         <div class="text-gray-500 text-sm font-medium mb-1">活跃相机型号</div>
         <div class="text-3xl font-bold">{{ Object.keys(currentStats.models).length }}</div>
      </div>
    </div>

    <!-- Map Section -->
    <div class="bg-white p-4 rounded-xl shadow-sm">
      <h2 class="text-xl font-semibold mb-4 text-gray-800 flex justify-between">
        <span>用户分布地图</span>
        <span class="text-sm font-normal text-gray-500 self-center">展示: {{ viewMode === 'unique' ? '独立用户数' : '总开启次数' }}</span>
      </h2>
      <div id="map"></div>
    </div>

    <!-- Main Charts Row -->
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
      <!-- Brands -->
      <div class="bg-white p-6 rounded-xl shadow-sm">
        <h3 class="text-lg font-semibold mb-4">相机品牌分布</h3>
        <div class="chart-container">
          <canvas id="brandChart"></canvas>
        </div>
      </div>
      
      <!-- Top Models -->
      <div class="bg-white p-6 rounded-xl shadow-sm">
        <h3 class="text-lg font-semibold mb-4">热门型号 Top 10</h3>
        <div class="chart-container">
          <canvas id="modelChart"></canvas>
        </div>
      </div>
    </div>

    <!-- Secondary Charts Row -->
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
      <!-- User Retention / Usage Freq -->
      <div class="bg-white p-6 rounded-xl shadow-sm">
        <h3 class="text-lg font-semibold mb-4">用户活跃频次 (每周)</h3>
        <div class="chart-container">
          <canvas id="usageChart"></canvas>
        </div>
        <p class="text-xs text-gray-400 mt-2 text-center">
          重度用户 (6+次/周): {{ data.weekly_usage?.heavy_users || 0 }} 
          ({{ ((data.weekly_usage?.heavy_ratio || 0) * 100).toFixed(1) }}%)
        </p>
      </div>

      <!-- Languages -->
      <div class="bg-white p-6 rounded-xl shadow-sm">
        <h3 class="text-lg font-semibold mb-4">语言分布</h3>
        <div class="chart-container">
          <canvas id="langChart"></canvas>
        </div>
      </div>
    </div>

    <!-- Detailed City Breakdown -->
    <div class="bg-white p-6 rounded-xl shadow-sm overflow-hidden">
      <h3 class="text-lg font-semibold mb-4">城市详情 Top 50</h3>
      <div class="overflow-x-auto">
        <table class="w-full text-left border-collapse">
          <thead>
            <tr class="bg-gray-50 border-b">
              <th class="p-3">城市</th>
              <th class="p-3">数量</th>
              <th class="p-3">主要品牌</th>
              <th class="p-3">主要型号</th>
            </tr>
          </thead>
          <tbody>
            <tr v-for="city in topCities" :key="city.name" class="border-b hover:bg-gray-50">
              <td class="p-3 font-medium">{{ city.name }}</td>
              <td class="p-3">{{ city.count }}</td>
              <td class="p-3 text-sm text-gray-600">{{ city.topBrand }}</td>
              <td class="p-3 text-sm text-gray-600">{{ city.topModel }}</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

  </div>
</div>

<script>
const { createApp, ref, computed, onMounted, watch, nextTick } = Vue;

const App = {
  setup() {
    const error = ref(null);
    const loading = ref(false);
    const data = ref(null);
    const duration = ref('7');
    const token = ref('');
    const viewMode = ref('total'); // 'total' or 'unique'
    
    const durations = [
      { label: '7D', val: '7' },
      { label: '30D', val: '30' },
      { label: 'All', val: 'all' }
    ];

    let map = null;
    let markersCluster = null;
    let charts = {};

    // Computed Stats based on View Mode
    const currentStats = computed(() => {
      if (!data.value) return {};
      if (viewMode.value === 'unique') {
        return {
          cities: data.value.city_unique_totals || {},
          brands: data.value.brand_unique_totals || {},
          models: data.value.model_unique_totals || {},
          total: data.value.global_unique_total || 0,
          label: '独立用户数'
        };
      }
      return {
        cities: data.value.city_totals || {},
        brands: data.value.brand_totals || {},
        models: data.value.model_totals || {},
        total: (Object.values(data.value.city_totals || {}).reduce((a,b)=>a+b,0)),
        label: '总开启次数'
      };
    });
    
    // Top Cities List
    const topCities = computed(() => {
        if (!data.value) return [];
        const source = currentStats.value.cities;
        return Object.entries(source)
            .sort((a,b) => b[1] - a[1])
            .slice(0, 50)
            .map(([name, count]) => ({
                name: decodeURIComponent(name),
                count,
                // Rough mapping for demonstration if brand/model not available in unique view easily without heavy processing
                topBrand: '-', 
                topModel: '-'
            }));
    });

    // Mapbox/OSM Init
    const initMap = () => {
      if (map) return;
      
      // Initialize map container
      map = L.map('map', { 
        minZoom: 2,
        worldCopyJump: true // Seamless world wrapper
      }).setView([20, 0], 2);
      
      // Using a cleaner, faster tile server (CartoDB Positron)
      const tileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 19
      });
      tileLayer.addTo(map);
      
      // Initialize Cluster Group
      markersCluster = L.markerClusterGroup({
        chunkedLoading: true, // Async loading for large datasets (faster UI)
        maxClusterRadius: 50, // Smaller radius = more detailed clusters
        spiderfyOnMaxZoom: true,
        showCoverageOnHover: false, // Cleaner look
        zoomToBoundsOnClick: true,
        
        // Customize the cluster icon to look like a "Heat Blob" with count
        iconCreateFunction: function(cluster) {
           const count = cluster.getChildCount();
           let bgColor = 'bg-blue-500';
           
           // Color scale: Blue -> Emerald -> Yellow -> Orange -> Red
           if (count > 10) bgColor = 'bg-emerald-500';
           if (count > 50) bgColor = 'bg-yellow-500';
           if (count > 200) bgColor = 'bg-orange-500';
           if (count > 1000) bgColor = 'bg-red-500';
           
           // Use Tailwind classes inside divIcon? HTML inside divIcon is just string.
           // We need inline styles or standard CSS since tailwind might not be parsed inside dynamic JS strings if JIT not aware 
           // (but CDN usually works fine if classes are common). 
           // Let's use standard Tailwind classes but wrapped safely.
           
           /* 
             Note: Tailwind CDN parses DOM on load. Dynamic content might need a nudge or standard CSS.
             But background colors are usually safe if used elsewhere.
             Let's use style attributes to be 100% sure about colors.
           */
           
           let colorHex = '#3b82f6'; // blue-500
           if (count > 10) colorHex = '#10b981'; // emerald-500
           if (count > 50) colorHex = '#f59e0b'; // yellow-500
           if (count > 200) colorHex = '#f97316'; // orange-500
           if (count > 1000) colorHex = '#ef4444'; // red-500

           return L.divIcon({ 
             html: `<div style="background-color: ${colorHex};" class="flex items-center justify-center w-10 h-10 text-white rounded-full text-xs font-bold shadow-lg border-2 border-white/50 opacity-90 transition-transform hover:scale-110">
                      ${count > 999 ? (count/1000).toFixed(1)+'k' : count}
                   </div>`, 
             className: 'bg-transparent border-none', // Override default Leaflet box
             iconSize: L.point(40, 40)
           });
        }
      });
      
      map.addLayer(markersCluster);
    };

    const updateProgressBar = (processed, total, elapsed, layersArray) => {
       // Optional: could show a loading bar if really heavy
    };

    const updateMap = () => {
      if (!map) initMap();
      markersCluster.clearLayers();
      
      const stats = currentStats.value.cities;
      const coordsMap = data.value.city_coords || {};
      const newMarkers = [];

      Object.entries(stats).forEach(([city, count]) => {
        const decCity = decodeURIComponent(city);
        const latlon = coordsMap[city] || coordsMap[decCity];
        
        if (!latlon || !latlon.lat) return;

        const lat = parseFloat(latlon.lat);
        const lon = parseFloat(latlon.lon);

        if (isNaN(lat) || isNaN(lon)) return;

        // Leaflet.markercluster supports custom icons for markers too if we want
        // But default blue pin is fine. 
        // Maybe color code the pin by intensity?
        // Let's use CircleMarker instead for cleaner look, but Cluster Group works best with Markers usually
        // Note: CircleMarker support in MarkerCluster is sometimes tricky. Standard Markers are safest.
        
        const marker = L.marker([lat, lon], {
            title: `${decCity}: ${count}`
        });

        marker.bindPopup(`
          <div class="p-2 min-w-[150px]">
            <h3 class="font-bold text-gray-800 text-base mb-2 border-b pb-2">${decCity}</h3>
            <div class="flex justify-between items-center mb-1">
              <span class="text-gray-500 text-sm">${viewMode.value === 'unique' ? '独立用户' : '开启次数'}</span>
              <span class="font-bold text-blue-600 text-lg">${count}</span>
            </div>
            <div class="text-xs text-gray-300 mt-2 text-right font-mono">
               ${lat.toFixed(4)}, ${lon.toFixed(4)}
            </div>
          </div>
        `);
        newMarkers.push(marker);
      });
      
      if (newMarkers.length > 0) {
        markersCluster.addLayers(newMarkers);
        // Only fit bounds on initial load effectively
        if (!window.mapInitialized) {
           try { 
             map.fitBounds(markersCluster.getBounds(), { padding: [50, 50] }); 
             window.mapInitialized = true;
           } catch(e){}
        }
      }
    };

    const loadStats = async (days) => {
      duration.value = days;
      loading.value = true;
      error.value = null;
      
      try {
        const headers = token.value ? { "X-Stats-Token": token.value } : {};
        const url = `/api/telemetry-stats?days=${days}&token=${token.value || ''}`;
        
        const res = await fetch(url);
        if (res.status === 401) {
             throw new Error("Unauthorized: Please enter valid Token");
        }
        if (!res.ok) throw new Error(`API Error: ${res.status}`);
        
        const json = await res.json();
        data.value = json;
        loading.value = false;
        
        await nextTick();
        renderAll();
      } catch (e) {
        error.value = e.message;
        console.error(e);
        loading.value = false;
      }
    };
    
    // Watch view mode to re-render without fetching
    watch(viewMode, () => {
        renderAll();
    });

    const renderAll = () => {
        if (!data.value) return;
        renderCharts();
        updateMap();
    };

    const renderCharts = () => {
      // Helper to destroy old charts
      ['brand', 'model', 'lang', 'usage'].forEach(k => {
          if (charts[k]) {
              charts[k].destroy();
              charts[k] = null;
          }
      });
      
      const stats = currentStats.value;
      const fullData = data.value;

      try {
        // Brands
        if (document.getElementById('brandChart')) {
          charts.brand = createChart('brandChart', 'doughnut', stats.brands, 'Brands');
        }
        
        // Models (Top 10)
        if (document.getElementById('modelChart')) {
          charts.model = createChart('modelChart', 'bar', stats.models, 'Models', 10);
        }

        // Weekly Usage
        if (document.getElementById('usageChart') && fullData.weekly_usage && fullData.weekly_usage.buckets) {
           const ctx = document.getElementById('usageChart');
           charts.usage = new Chart(ctx, {
            type: 'bar',
            data: {
              labels: Object.keys(fullData.weekly_usage.buckets),
              datasets: [{
                label: 'Users',
                data: Object.values(fullData.weekly_usage.buckets),
                backgroundColor: '#3b82f6'
              }]
            },
            options: { responsive: true, maintainAspectRatio: false }
          });
        }

        // Langs
        if (document.getElementById('langChart')) {
           const langParams = viewMode.value === 'unique' ? fullData.language_totals : fullData.language_totals;
           charts.lang = createChart('langChart', 'pie', langParams, 'Language');
        }
      } catch (e) {
        console.warn("Chart render failed", e);
      }
    };

    const createChart = (id, type, dataObj, label, limit = 0) => {
      const cvs = document.getElementById(id);
      if(!cvs) return null;
      
      let sorting = Object.entries(dataObj || {}).sort((a, b) => b[1] - a[1]);
      
      if (limit > 0) {
          sorting = sorting.slice(0, limit);
      }

      const labels = sorting.map(x => decodeURIComponent(x[0]));
      const values = sorting.map(x => x[1]);

      return new Chart(cvs, {
        type: type,
        data: {
          labels: labels,
          datasets: [{
            label: label,
            data: values,
            backgroundColor: [
              '#3b82f6', '#10b981', '#f59e0b', '#ef4444', 
              '#8b5cf6', '#ec4899', '#6366f1', '#14b8a6'
            ],
            borderWidth: 1
          }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'bottom' }
            }
        }
      });
    };
    
    // Save/Load token
    const saveToken = () => {
        if(token.value) localStorage.setItem('niyien_stats_token', token.value);
    };
    
    onMounted(() => {
        const saved = localStorage.getItem('niyien_stats_token');
        if(saved) token.value = saved;
        if(saved) loadStats('7');
    });

    return {
      error, loading, data, duration, token, durations, viewMode,
      topCities, currentStats,
      loadStats, saveToken
    };
  }
};

createApp(App).mount('#app');

</script>
</body>
</html>
